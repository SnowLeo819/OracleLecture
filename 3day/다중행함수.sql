-- 다중행 함수

SELECT SAL FROM EMP;

SELECT SUM(SAL) AS TOTAL
FROM EMP;

SELECT TRUNC(AVG(SAL))  AS AVG
FROM EMP;

SELECT MAX(SAL) AS MAX,
           MIN(SAL) AS MIN
FROM EMP;

-- 카운트함수는 기본적으로 NULL 값은 빼고 계산함
SELECT COUNT(*) AS COUNT_ALL,
          COUNT(SAL) AS COUNT_SAL,
          COUNT(COMM) AS COUNT_COMM
FROM EMP;

SELECT * FROM EMP;

SELECT SUM(SAL) AS TOTAL,
           TRUNC(AVG(SAL))  AS AVG,
           MAX(SAL) AS MAX,
           MIN(SAL) AS MIN,
           COUNT(*) AS COUNT
FROM EMP;

SELECT COUNT(*)
FROM EMP
WHERE DEPTNO = 10;

-- 30부서에  월급많이 월급조금

SELECT MAX(SAL) AS MAX,
          MIN(SAL) AS MIN
FROM EMP
WHERE DEPTNO = 30;

-- 제일 최근에 입사

SELECT MAX(HIREDATE) AS HIRE_LAST,
MIN(HIREDATE) AS HIRE_FIRST
FROM EMP;


SELECT TRUNC(AVG(SAL)) AS AVG, '10' AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT TRUNC(AVG(SAL)) AS AVG, '20' AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT TRUNC(AVG(SAL)) AS AVG, '30' AS DEPTNO FROM EMP WHERE DEPTNO = 30;


SELECT TRUNC(AVG(SAL)) AS AVG,
            DEPTNO
FROM EMP
GROUP BY DEPTNO
ORDER BY AVG DESC;   -- 정렬은 항상 제일 나중에..


SELECT DEPTNO, JOB, TRUNC(AVG(SAL)) AS AVG, COUNT(JOB) AS COUNT, TRUNC(AVG(SAL))/COUNT(JOB) AS AVG_SAL
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO,AVG;

-- 부서 인원수 
SELELCT 


-- HAVING 절 ,..  GROUP 을 써야만 사용   ( WHERE 와 같은 조건절임 )
-- 단일 조건 : WHERE , 다중조건 : HAVING

SELECT DEPTNO, JOB, TRUNC(AVG(SAL)) AS AVG
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;


-- SELECT 기본형..
SELECT DEPTNO, JOB, TRUNC(AVG(SAL)) AS AVG  -- 데이터 활용 범위 
FROM EMP                                                   -- 데이터 가져올 위치
WHERE SAL <= 3000                                     -- 단일 데이터 조건 부여
GROUP BY DEPTNO, JOB                                -- 그룹 데이터 지정
HAVING AVG(SAL) >= 2000                            -- 그룹 데이터 조건부여
ORDER BY DEPTNO, JOB;                                -- 정렬

--부서별 직책평균 급여가 500 이상인 사람들

SELECT DEPTNO, JOB,  TRUNC(AVG(SAL)) AS AVG
FROM EMP

GROUP BY DEPTNO, JOB
HAVING AVG(SAL)  >= 1000
ORDER BY DEPTNO, JOB;

-- 계산값 출력
SELECT JOB, SUM(SAL) AS SAL_TOTAL
FROM EMP
GROUP BY ROLLUP(JOB);


SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY (JOB,DEPTNO);

-- 부분합 추가  // 보고서 작성할 때 활용..
--GROUP BY ROLLUP
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(JOB,DEPTNO);


SELECT DEPTNO, JOB, COUNT(*) AS COUNT, MAX(SAL) AS HIGH, SUM(SAL) AS TOTAL, TRUNC(AVG(SAL)) AS AVG
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;


SELECT DEPTNO, JOB, COUNT(*) AS COUNT
FROM EMP
GROUP BY DEPTNO,JOB
ORDER BY DEPTNO,JOB;

SELECT DEPTNO, JOB, COUNT(*) AS COUNT
FROM EMP
GROUP BY GROUPING SETS(DEPTNO,JOB)
ORDER BY DEPTNO,JOB;

SELECT DEPTNO, JOB, COUNT(*) AS COUNT
FROM EMP
GROUP BY GROUPING SETS((DEPTNO,JOB),()) -- 빈 괄호 대신 NULL 을 넣어도 된다.
ORDER BY DEPTNO,JOB;

SELECT DEPTNO, JOB, COUNT(*), MAX(SAL) AS HIGH, SUM(SAL) AS SUM_TOTAL, TRUNC(AVG(SAL)) AS AVG,
GROUPING (DEPTNO),
GROUPING (JOB)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;
--GROUP BY ROLLUP(DEPTNO

SELECT DEPTNO, JOB, COUNT(*), MAX(SAL) AS HIGH, SUM(SAL) AS SUM_TOTAL, TRUNC(AVG(SAL)) AS AVG,
GROUPING (DEPTNO),                 -- 그룹화 된 항목에 GROUPING COUNT 가 표시됨
GROUPING (JOB)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB) 
ORDER BY DEPTNO, JOB;

SELECT DECODE( GROUPING(DEPTNO), 1, '부서별 총합', DEPTNO) AS DEPT_NUM,
            DECODE( GROUPING(JOB), 1, '직급별 총합', JOB) AS JOB_NUM,
DEPTNO, JOB, COUNT(*), MAX(SAL) AS HIGH, SUM(SAL) AS SUM_TOTAL, TRUNC(AVG(SAL)) AS AVG
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB) 
ORDER BY DEPTNO, JOB;


--LISTAGG // 묶어서 옆으로 출력
-- 그룹에 하위 항목들을 옆으로 출력,,   
SELECT DEPTNO,
            LISTAGG(ENAME,' , ')                                              --  LISTAGG ( 그룹명, 구분자 )
            WITHIN GROUP( ORDER BY SAL DESC ) AS ENAMES    -- WITHIN GROUP( 정렬 기준 [ex) ORDER BY SAL DESC ])
FROM EMP
GROUP BY DEPTNO;

-- 추출...
SELECT LISTAGG(ENAME, ',')
            WITHIN GROUP( ORDER BY ENAME ) AS ENAMES
FROM EMP
WHERE JOB IN ('MANAGER','SALESMAN');


-----------------------------------------------
-- TABLE 만들기  ( 권한 필요함 // 없으면 SYS 계정에서 부여함.) 

CREATE TABLE MONTH_SALES (
--  컬럼명  데이터 타입(길이) 반복
        PRODUCT_ID VARCHAR2(10),
        MONTH VARCHAR2(10),
        COMPANY VARCHAR2(20),
        MONEY NUMBER(10)
);

INSERT INTO MONTH_SALES  VALUES('P001','2021/01','SAMSUNG',10000);
INSERT INTO MONTH_SALES  VALUES('P001','2021/02','SAMSUNG',12000);
INSERT INTO MONTH_SALES  VALUES('P001','2021/05','SAMSUNG',15000);
INSERT INTO MONTH_SALES  VALUES('P001','2021/08','SAMSUNG',18000);
INSERT INTO MONTH_SALES  VALUES('P001','2021/12','SAMSUNG',9000);
INSERT INTO MONTH_SALES  VALUES('P002','2021/01','APPLE',30000);
INSERT INTO MONTH_SALES  VALUES('P002','2021/02','APPLE',19000);
INSERT INTO MONTH_SALES  VALUES('P002','2021/05','APPLE',12000);
INSERT INTO MONTH_SALES  VALUES('P002','2021/08','APPLE',13000);
INSERT INTO MONTH_SALES  VALUES('P002','2021/12','APPLE',100000);
INSERT INTO MONTH_SALES  VALUES('P003','2021/01','LG',12000);
INSERT INTO MONTH_SALES  VALUES('P003','2021/02','LG',80000);
INSERT INTO MONTH_SALES  VALUES('P003','2021/05','LG',101000);
INSERT INTO MONTH_SALES  VALUES('P003','2021/08','LG',50000);
INSERT INTO MONTH_SALES  VALUES('P003','2021/12','LG',19000);

DELETE FROM MONTH_SALES;

SELECT * FROM MONTH_SALES;

-- INSERT  // SELECT //  UPDATE  // DELETE  
-- CREATE // READ // UPDATE // DELETE

--트랜젝션
-- 되돌리기
ROLLBACK;
-- 모든 내용 마무리 할때. ( 롤백 안됨 )
COMMIT;

--테이블 삭제
DROP TABLE MONTH_SALES;


SELECT PRODUCT_ID, MONTH, SUM(MONEY) AS TOTAL
FROM MONTH_SALES
GROUP BY ROLLUP(PRODUCT_ID, MONTH);

SELECT MONTH, PRODUCT_ID, SUM(MONEY) AS TOTAL
FROM MONTH_SALES
GROUP BY ROLLUP(MONTH, PRODUCT_ID);


--GROUP BY CUBE : 경우의 수에 따른 정렬.. 데이터 양이 많고 오래걸림..
SELECT MONTH, PRODUCT_ID, SUM(MONEY) AS TOTAL
FROM MONTH_SALES
GROUP BY CUBE(MONTH, PRODUCT_ID);

SELECT PRODUCT_ID, MONTH, COMPANY,SUM(MONEY) AS TOTAL
FROM MONTH_SALES
GROUP BY GROUPING SETS ((PRODUCT_ID, MONTH),COMPANY);
--ORDER BY (PRODUCT_ID, MONTH);


SELECT 
    CASE GROUPING(PRODUCT_ID) WHEN 1 THEN '모든 상품' ELSE PRODUCT_ID END AS PRODUCT_ID,
    CASE GROUPING(MONTH)        WHEN 1 THEN '모든 월' ELSE MONTH END AS MONTH,
    SUM(MONEY) AS MONEY_TOTAL
FROM  MONTH_SALES
GROUP BY ROLLUP(PRODUCT_ID, MONTH)  ;

--SELECT DECODE( GROUPING(DEPTNO), 1, '부서별 총합', DEPTNO) AS DEPT_NUM,
--            DECODE( GROUPING(JOB), 1, '직급별 총합', JOB) AS JOB_NUM,
--DEPTNO, JOB, COUNT(*), MAX(SAL) AS HIGH, SUM(SAL) AS SUM_TOTAL, TRUNC(AVG(SAL)) AS AVG
--FROM EMP
--GROUP BY ROLLUP(DEPTNO, JOB) 
--ORDER BY DEPTNO, JOB;


-----------------------------
--PIVOT 함수

SELECT DEPTNO, JOB, MAX(SAL) AS HIGH
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

SELECT DEPTNO, JOB, MAX(SAL) AS HIGH
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;



-- 서브쿼리.. // 쿼리 안에 쿼리
SELECT DEPTNO, JOB, SAL FROM EMP;

--SELECT * FROM (피벗 시킬 쿼리.. 방향 바꿀 쿼리...
--PIVOT(그룹함수(집계할 컬럼) FOR 피벗 컬럼 IN  (피벗컬럼값 AS 별명))

SELECT *
FROM ( SELECT DEPTNO , JOB , SAL FROM EMP )
PIVOT (MAX(SAL) FOR DEPTNO IN (10,20,30))
--MAX(SAL) FOR DEPTNO IN (10,20,30)
ORDER BY JOB;



SELECT * FROM  ( SELECT DEPTNO , JOB , SAL FROM EMP )
PIVOT ( MAX(SAL) FOR JOB IN ( 
    'CLERK' AS 사원 ,
    'SALESMAN' AS 영업사원, 
    'MANAGER' AS 관리자,
    'ANALYST' AS 분석가,
    'PRESIDENT' AS 사장
    ) )
ORDER BY DEPTNO;

-- 월별 입사 인력..
SELECT JOB, TO_CHAR(HIREDATE,'MM') AS HIRE_MONTH FROM EMP;

-- TO_CHAR(HIREDATE,'MM') : 2자릿수(01,02,03 ...)  // TO_CHAR(HIREDATE,'FMMM') : 1~자리( 1,2,3,...10,11,12...)

SELECT * FROM ( SELECT JOB, TO_CHAR(HIREDATE,'FMMM')||'월' AS HIRE_MONTH FROM EMP)
PIVOT (COUNT(*) FOR HIRE_MONTH IN ( '1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'));

SELECT JOB, TO_CHAR(HIREDATE,'FMMM') AS HIRE_MONTH, COUNT(*)
FROM EMP
GROUP BY HIREDATE, JOB;


------------------------------------------
--  중복되는 요소에만 표시ㅣ.
SELECT * 
FROM EMP E  , DEPT D
WHERE E.DEPTNO= D.DEPTNO;  -- // INNER JOIN  바로연결해서 사용하는 JOIN

SELECT EMP.EMPNO , EMP.ENABE. ,D.DEP, DDEFPNO
;




-- SELF JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
            E2.EMPNO AS MGR_NO,
            E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;
            
            
-- 외부 조인 OUTER JOIN  //  대상테이블에 값이 없어도 가져와라,.
-- + 를 어느 방향에 붙이는가에 따라 값이 다름..  오라클에서만 사용가능

-- 기준절이 왼쪽..  (+)가 오른쪽.    // LEFT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
            E2.EMPNO AS MGR_NO,
            E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+)    -- 상급자가 없는 경우도 가져온것.
ORDER BY E1.EMPNO;

-- 기준절이 오른쪽 ....    (+) 왼쪽.    // RIGHT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
            E2.EMPNO AS MGR_NO,
            E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR (+) = E2.EMPNO   -- 하급자가 없는 경우도 가져온것.(관리자가 아닌 사람..)
ORDER BY E1.EMPNO;


--  ANSI JOIN  // 표준 조인   교집합요소는 추가로 붙이지 않음,..,
--  아래 세가지 모두 같은 의미..
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO
;

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D USING (DEPTNO)
ORDER BY DEPTNO, E.EMPNO;

-- 주로 사용..
SELECT D.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON (E.DEPTNO= D.DEPTNO)
-- 이 자리에 조건절 추가 가능
ORDER BY DEPTNO, E.EMPNO;

-- ex)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D ON (E.DEPTNO= D.DEPTNO)
WHERE SAL < 3000
ORDER BY DEPTNO, E.EMPNO;


-- LEFT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
            E2.EMPNO AS MGR_NO,
            E2.ENAME AS MGR_NAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;

-- RIGHT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
            E2.EMPNO AS MGR_NO,
            E2.ENAME AS MGR_NAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;

--FULL OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
            E2.EMPNO AS MGR_NO,
            E2.ENAME AS MGR_NAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;










